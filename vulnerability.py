import argparse
import requests
import logging
import hashlib
import os
import csv
from datetime import datetime

# Ruta donde se guardarán los reportes
REPORTS_DIR = "reportes"

# Crear el directorio de reportes si no existe
os.makedirs(REPORTS_DIR, exist_ok=True)

# Configuración de logging
logging.basicConfig(filename='vulnerability_headers.log',
                    level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de headers de seguridad a verificar
security_headers = [
    "Strict-Transport-Security",
    "Content-Security-Policy",
    "X-Content-Type-Options",
    "X-Frame-Options",
    "X-XSS-Protection",
    "Referrer-Policy",
    "Permissions-Policy"
]

# Función para obtener la ruta del directorio de reportes
def get_report_directory():
    """Retorna la ruta del directorio donde se guardan los reportes."""
    return os.path.abspath(REPORTS_DIR)

# Función para generar el reporte
def generate_report(content, task_name):
    """Genera un reporte en formato CSV y retorna el nombre y hash del archivo."""
    # Nombre del archivo basado en la fecha y la tarea
    date_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_filename = f"{task_name}_{date_str}.csv"
    report_path = os.path.join(REPORTS_DIR, report_filename)
    
    # Escribir el contenido en el archivo CSV
    with open(report_path, mode="w", newline="") as file:
        writer = csv.writer(file)
        for row in content:
            writer.writerow(row)
    
    # Calcular el hash SHA256 del archivo para validación
    hash_sha256 = hashlib.sha256()
    with open(report_path, "rb") as file:
        for chunk in iter(lambda: file.read(4096), b""):
            hash_sha256.update(chunk)
    
    # Mostrar los detalles del reporte generado
    print(f"Tarea '{task_name}' ejecutada el {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Reporte generado: {report_path}")
    print(f"Hash SHA256 del reporte: {hash_sha256.hexdigest()}")
    print(f"El archivo se guardó en el directorio: {get_report_directory()}")  # Mostrar directorio
    
    return report_path, hash_sha256.hexdigest()

# Función para verificar los headers de seguridad
def vulnerability_headers(url):
    """Verifica los encabezados de seguridad en una página web."""
    try:
        response = requests.get(url)
        headers = response.headers
        logging.info(f'Analizando {url}')
        
        secure_headers_found = 0
        content = [["Header", "Status"]]
        
        for header in security_headers:
            if header in headers:
                content.append([header, "Encontrado"])
                secure_headers_found += 1
            else:
                content.append([header, "No encontrado"])
        
        if secure_headers_found == 0:
            logging.warning(f'La página {url} no tiene headers de seguridad importantes.')
        
        # Generar el reporte
        return generate_report(content, "Vulnerability_Headers")
    
    except requests.exceptions.RequestException as e:
        logging.error(f"Error al verificar {url}: {e}")
        print(f"Error al verificar {url}: {e}")

# Configuración del parser de argparse
def main():
    parser = argparse.ArgumentParser(description="Verificar encabezados de seguridad de una página web.")
    parser.add_argument("url", type=str, help="URL de la página a verificar")
    
    args = parser.parse_args()

    # Llamar la función de verificación de headers
    vulnerability_headers(args.url)

if __name__ == "__main__":
    main()